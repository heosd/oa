<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <style>
        * {
            box-sizing: border-box;
        }

        @page {
            size: A4;
            marks: crop cross;
        }

        .page {
            width: 210mm;
            height: 297mm;
            margin: 0 auto;
            border: 1px solid black;
            display: block;
            padding: 0.5cm 0.5cm 0.5cm 0.5cm;
        }

        .color1 {
            color: #DCE2F0;
        }

        .bg1 {
            background-color: #DCE2F0;
        }

        .color2 {
            color: #50586C;
        }

        .bg2 {
            background-color: #50586C;
        }

        .font1-fantasy {
            color: #1E4174;
            font-family: fantasy;
        }

        body {
            font-family: "Open Sans", sans-serif;
            line-height: 1.25;
        }


        table {
            border-collapse: collapse;
        }

        th,
        td {
            border: 1px solid #ccc;
            padding: 8px;
        }

        tr:hover {
            background: #50586C;
            color: #DCE2F0;
        }

        caption {
            text-align: left;
        }

        /* Check box area */
        .select-checkbox {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            column-gap: 5px;
        }

        .select-checkbox-types {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            column-gap: 5px;
        }
    </style>
</head>

<body>

    <div id="area-test">
    </div>

    <div id="area-select" class="page">
        <h2>Select years</h2>
        <div id="selectYears" class="select-checkbox"></div>

        <h2>Group</h2>
        <div>
            <select id="selectG1" onchange="onChangeG1(this.value)">
                <option value="1y" selected="selected">Year</option>
                <option value="6m">6 Month</option>
                <option value="3m">3 Month</option>
                <option value="1m">1 Month</option>
            </select>
        </div>


        <!-- <h2>Types</h2> -->
        <div id="selectTypes"></div>

        <h2>Color scheme</h2>
        <div id="selectColors"></div>
    </div>
    <div id="area-plot-total"></div>
    <div id="area-plot-year"></div>
    <section id="testarea" class="page">
        <div id="sum-date-plot"></div>

        <div id="sum-type-plot"></div>
    </section>

    <!-- Summary -->
    <section class="page">
        <div class="color2">
            <h1>Budget data report</h1>

            <table style="width: 100%; text-align: center;">
                <caption>Data source - <span id="sum-count-datasource"></span> items. first <span
                        id="sum-count-first"></span> items</caption>
                <thead>
                    <tr id="sum-tr-rowcol">
                    </tr>
                </thead>
                <tbody id="sum-area-datasource"></tbody>
            </table>

            <table>
                <caption>Option input</caption>
                <thead>
                    <tr>
                        <th>Attr</th>
                        <th>Value</th>
                        <th>O</th>
                        <th>X</th>
                        <th>Groups (count)</th>
                    </tr>
                </thead>
                <tbody id="sum-area-opt"></tbody>
            </table>
        </div>
    </section>

    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6"></script>

    <script src="../js/Generator.js"></script>
    <script src="../js/DataBudget.js"></script>
    <script src="../js/Legend.js"></script>

    <script>
        setTimeout(async () => {
            const data = await Generator.Generate(300);

            const budget = new DataBudget();
            budget.dataSource = data;
            budget.opt = {
                date: 'date',
                price: 'price',
                count: 'count',
                type: ['name', 'type1', 'type2']
            }

            budget.processClone();
            budget.execDate();
            budget.execPCV();
            budget.execType();
            budget.execYears();

            // console.log(budget.opt);
            // console.log(budget.cloned);
            // console.log(budget.ssDate);
            // console.log(budget.ssPCV);
            // console.log(budget.ssType);
            // console.log(budget.ssYear);

            console.log(budget);

            // global access
            window.getBudget = () => budget;

            refreshUserSelect(budget);
            filterBudgetBySelected(budget); // sets budget.dataFiltered
            // refreshSummary(budget);

            updateAllRectLegend();
        }, 1);

        function createE(tag, text) {
            const e = document.createElement(tag);
            if (undefined !== typeof text) {
                e.textContent = text;
            }

            return e;
        }

        function getDefaultPlot() {
            const budget = getBudget();

            const obj = {
                style: { fontSize: 12 },
                color: { type: 'categorical', legend: false, scheme: budget.selectedColorSchemeName },
                marginLeft: 100,
                marginBottom: 45,
                marginTop: 35,
                marginRight: 20,
                x: { grid: true, tickFormat: formatKRW },
                // y: { tickFormat: d => d.toString(), type: 'band' },
                marks: [
                    Plot.frame({ stroke: '#BBB' }),
                    Plot.ruleX([0]),
                ]
            };
            return obj;
        }

        function PlotGridX() {
            return Plot.gridX({ stroke: "white", strokeOpacity: 0.5 });
        }

        function refreshSummary(budget) {
            // // -- data source
            // document.getElementById('sum-count-datasource').textContent = budget.dataSource.length;

            // // cols
            // const trHeader = document.getElementById('sum-tr-rowcol');
            // const first = budget.dataSource[0];
            // const keys = Object.keys(first);
            // keys.forEach(k => trHeader.appendChild(createE('th', k)));

            // // 5 items or less
            // const maxLen = Math.min(5, budget.dataSource.length);
            // document.getElementById('sum-count-first').textContent = maxLen;
            // const areaDataSource = document.getElementById('sum-area-datasource');
            // for (let i = 0; i < maxLen; i++) {
            //     const item = budget.dataSource[i];
            //     const tr = document.createElement('tr');
            //     keys.forEach(k => {
            //         const str = item[k].toString();
            //         let short = item[k].toString().substring(0, 8);
            //         if (8 < str.length) {
            //             short = short + '..';
            //         }
            //         const th = createE('th', short);
            //         th.setAttribute('title', str);
            //         tr.appendChild(th);
            //     });
            //     areaDataSource.appendChild(tr);
            // }

            // // -- option
            // const opt = budget.opt;
            // const areaOpt = document.getElementById('sum-area-opt');

            // // preprocess
            // const dateGroups = budget.ssDate.list.map(d => `${d.y} [${d.count}]`).join(', ');

            // const listOptions =
            //     [
            //         ['date', opt.date, budget.ssDate.valid.toString(), budget.ssDate.invalid.toString(), dateGroups],
            //         ['price', opt.price, budget.ssPCV.pvalid, budget.ssPCV.pinvalid, budget.ssPCV.prange.join(' ~ ')],
            //         ['count', opt.count, budget.ssPCV.cvalid, budget.ssPCV.cinvalid, budget.ssPCV.crange.join(' ~ ')],
            //     ];

            // budget.ssType.forEach(d => {
            //     const typeGroups = d.list.map(typeItem => `${typeItem.key} [${typeItem.count}]`).join(', ');
            //     const item = ['type', d.colOrigin, d.valid, d.invalid, typeGroups];
            //     listOptions.push(item);
            // });

            // listOptions.forEach(line => {
            //     const trOpt = document.createElement('tr');
            //     line.forEach(d => {
            //         const td = createE('td', d);
            //         trOpt.appendChild(td);
            //     });
            //     areaOpt.appendChild(trOpt);
            // });

            // max range
            const listMax = [];

            if (budget.optDate) {
                listMax.push(Math.max(...budget.ssDate.list.map(d => d.sum)));
            }

            if (budget.ssType && 0 < budget.ssType.length) {
                budget.ssType.forEach(ss => {
                    listMax.push(Math.max(...ss.list.map(d => d.sum)));
                });
            }

            const max = Math.max(...listMax);
            const range = roundUp(max, 1.3);

            const plotTotal = document.getElementById('area-plot-total');
            plotTotal.innerHTML = '';

            // -- Plot date
            if (budget.optDate) {
                const plot = createDatePlot(budget.dataFiltered, range);
                appendChildPage(plotTotal, plot);
            }

            // -- Plot Types All
            if (budget.ssType && 0 < budget.ssType.length) {
                budget.ssType.forEach((d, i) => {
                    const plot = createTypePlot(budget.dataFiltered, d, range);
                    appendChildPage(plotTotal, plot);
                });
            }
        }

        function createLabelCheck(text, value) {
            const label = document.createElement('label');
            const input = document.createElement('input');
            input.setAttribute('type', 'checkbox');
            input.setAttribute('value', value);
            label.appendChild(input);
            label.appendChild(document.createTextNode(text));

            return [label, input];
        }

        function refreshUserSelect(budget) {
            // -- Years
            const years = document.getElementById('selectYears');
            years.innerHTML = '';

            budget.ssDate.list.forEach(d => {
                const [l, i] = createLabelCheck(d.y, d.y);
                i.addEventListener('change', () => onChangeYear(budget));
                years.appendChild(l);
            });

            // -- Types depends on years

            // -- Types
            // const types = document.getElementById('selectTypes');
            // types.innerHTML = '';

            // budget.ssType.forEach(d => {
            //     const [l, i] = createLabelCheck(d.colOrigin, d.col);
            //     i.addEventListener('change', () => onChangeType(budget));
            //     types.appendChild(l);
            // });

            // -- Group
            onChangeG1();

            // -- Colors
            refreshUserSelectColorScheme();
        }

        function refreshUserSelectTypes() {
            const budget = getBudget();

            // from dataFiltered, modify dataFiltered
            // set selectedTypes: [{col: 'type0', list: ['o1', 'o2']}]

            const p = document.getElementById('selectTypes');
            p.innerHTML = '';

            budget.selectedTypes = {};

            budget.ssType.forEach(type => {
                const keyType = type.col;
                const group = d3.rollups(budget.dataFiltered, list => list.reduce((a, b) => a + b.v, 0), d => d[keyType]);
                const desc = group.toSorted((a, b) => b[1] - a[1]);

                // title
                const h2 = document.createElement('h2');
                h2.textContent = `Type '${type.colOrigin}'`;

                // div group
                const div = document.createElement('div');
                div.classList.add('select-checkbox-types');

                // child checkbox
                desc.forEach(d => {
                    // d[0] - title, d[1] - value
                    const value = d[1].toLocaleString('en-US');

                    const label = createLabelCheck(`${d[0]} (${value})`, d[0]);
                    div.appendChild(label[0]);
                    const input = label[1];
                    input.setAttribute('name', type.col);
                    input.addEventListener('change', onChangeType);
                });

                p.appendChild(h2);
                p.appendChild(div);
            });
        }

        function refreshUserSelectColorScheme() {
            const budget = getBudget();

            const colors = document.getElementById('selectColors');
            const size = 20;

            const listColors = [
                [d3.schemeCategory10, 'category10'],
                [d3.schemeAccent, 'accent'],
                [d3.schemeDark2, 'dark2'],
                [d3.schemePaired, 'paired'],
                [d3.schemePastel1, 'pastel1'],
                [d3.schemePastel2, 'pastel2'],
                [d3.schemeSet1, 'set1'],
                [d3.schemeSet2, 'set2'],
                [d3.schemeSet3, 'set3'],
                [d3.schemeTableau10, 'tableau10'],
            ];

            listColors.forEach((d, i) => {
                const div = document.createElement('label');
                div.style.display = 'block';
                const id = `selectColorScheme_${i}`;
                div.setAttribute('id', id);

                const input = document.createElement('input');
                input.setAttribute('type', 'radio');
                input.setAttribute('name', 'selectColorScheme');
                input.addEventListener('change', (e) => {
                    budget.selectedColorScheme = d[0];
                    budget.selectedColorSchemeName = d[1];
                    onChangeColor();
                });
                div.appendChild(input);

                colors.appendChild(div);
                appendColorScheme('#' + id, d[0], size);
            });

            // -- default the first one
            colors.querySelector('input').setAttribute('checked', true);
            budget.selectedColorScheme = listColors[0][0];
            budget.selectedColorSchemeName = listColors[0][1];
        }

        function appendColorScheme(selector, listColors, size) {
            d3.select(selector)
                .insert('svg')
                .attr('width', 300)
                .attr('height', size)
                .selectAll('rect')
                .data(listColors)
                .join('rect')
                .attr('x', (d, i) => i * size)
                .attr('width', size)
                .attr('height', size)
                .attr('fill', d => d)

        }

        function onChangeYear(budget) {
            console.log('Year select changed');
            const years = document.getElementById('selectYears');
            const checked = Array.from(years.querySelectorAll(':checked')).map(d => d.value);
            console.log(checked);

            budget.selectedYears = checked;
            filterBudgetBySelected(budget);
            refreshUserSelectTypes();
            refreshSummary(budget);
        }

        // -- in every checkbox
        function onChangeType() {
            const p = this.parentElement.parentElement;
            const name = this.getAttribute('name');
            const checked = p.querySelectorAll(`input[name="${name}"]:checked`);
            const c = Array.from(checked).map(input => input.getAttribute('value'));

            const budget = getBudget();
            budget.selectedTypes[name] = c;

            // budget.selectedTypes.type0 = ['o1', 'o2']
            filterBudgetBySelected(budget);
            refreshSummary(budget);
            console.log(budget);
        }

        function onChangeG1() {
            const budget = getBudget();

            const v = document.getElementById('selectG1').value;

            const fn1y = (d) => d.d_y;
            const fn6m = (d) => {
                const half = 6 >= d.d_m ? '전반기' : '하반기';
                return `${d.d_y} ${half}`;
            };
            const fn3m = (d) => {
                const f = [
                    [3, '1/4'],
                    [6, '2/4'],
                    [9, '3/4'],
                    [12, '4/4'],
                ].find(item => d.d_m <= item[0]);

                return `${d.d_y} ${f[1]}`;
            };

            const fn1m = (d) => d.d_ym;

            const f = [
                ['1y', fn1y],
                ['6m', fn6m],
                ['3m', fn3m],
                ['1m', fn1m],
            ].find(item => v === item[0]);

            budget.selectedG1 = v;
            budget.selectedG1fn = f[1];

            filterBudgetBySelected(budget);
            refreshSummary(budget);
        }

        function onChangeColor() {
            // already processed
            const budget = getBudget();
            filterBudgetBySelected(budget);
            refreshSummary(budget);
        }

        function filterBudgetBySelected(budget) {
            // budget.dataFiltered

            budget.dataFiltered = budget.cloned.filter(d => {
                if (budget.selectedYears && 0 < budget.selectedYears.length) {
                    if (-1 === budget.selectedYears.indexOf(d.d_y)) {
                        return false;
                    }
                }

                return true;
            });

            if (budget.selectedG1fn) {
                budget.dataFiltered.forEach(d => d.g1 = budget.selectedG1fn(d));
            }

            // filter types
            if(budget.selectedTypes) {
                const types = Object.keys(budget.selectedTypes);
                types.forEach(type => {
                    if(budget.selectedTypes[type] && 0 < budget.selectedTypes[type].length) {
                        const list = budget.selectedTypes[type];
                        const fnFind = (src) => list.find(item => item === src[type]);
                        budget.dataFiltered = budget.dataFiltered.filter(fnFind);
                    }
                })
            }

            return budget.dataFiltered;
        }

        function formatKRW(krw) {
            if (0 === krw) {
                return '0';
            }

            const list = [
                [100000000, '억'],
                [10000000, '천만'],
                [1000000, '백만'],
                [100000, '십만'],
                [10000, '만'],
                [1000, '천'],
            ];

            const unit = list.find(d => d[0] <= krw ? true : false);
            const v = krw / unit[0];
            return v + unit[1];
        }

        function createSVG(w = 640, h) {
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            if (w) {
                svg.setAttribute('width', w);
            }

            if (h) {
                svg.setAttribute('height', h);
            }

            return svg;
        }

        function createDatePlot(dataSource, maxRange) {
            const budget = getBudget();
            const src = dataSource;

            const idx = d3.group(src, d => d.g1);
            const listLegend = Array.from(idx.keys()).sort();

            // plot
            const obj = getDefaultPlot();
            obj.x = { label: null, grid: true, tickFormat: formatKRW, domain: [0, maxRange] };
            obj.y = { label: 'Year', type: 'band' };
            obj.marginTop = 60;
            obj.marks.push(
                Plot.barX(src,
                    Plot.groupY({
                        x: 'sum'
                    }, {
                        x: 'v',
                        y: 'g1',
                        fill: 'g1',
                        tip: true,
                    }
                    )),
                Plot.text(src,
                    Plot.groupY({
                        x: 'sum',
                        text: d => d.reduce((a, b) => a + b.v, 0),
                    }, {
                        x: 'v',
                        y: 'g1',
                        textAnchor: 'start',
                        dx: 5,
                    }
                    )),
                PlotGridX(),
            );

            const plot = Plot.plot(obj);
            plot.appendChild(createRectLegend(listLegend, { color: budget.selectedColorScheme }));
            plot.addEventListener('dblclick', e => downloadSVG(e.target, 'years.svg'));

            return plot;
        }

        function createTypePlot(dataSource, type, maxRange) {
            const budget = getBudget();
            const col = type.col;
            const src = dataSource;

            const idx = d3.group(src, d => d.g1);
            const listLegend = Array.from(idx.keys()).sort();

            const obj = getDefaultPlot();

            // plot
            obj.x = {
                grid: true, label: null, domain: [0, maxRange], tickFormat: formatKRW,
                type: 'linear'
            };

            obj.y = {
                label: type.colOrigin
            }

            obj.marks.push(
                Plot.barX(src,
                    Plot.groupY({
                        x: 'sum'
                    }, {
                        x: 'v',
                        y: col,
                        fill: 'g1',
                        tip: true,
                        sort: { y: 'x', reverse: true }
                    }
                    )),
                Plot.text(src,
                    Plot.groupY({
                        x: 'sum',
                        text: d => d.reduce((a, b) => a + b.v, 0),
                    }, {
                        x: 'v',
                        y: col,
                        textAnchor: 'start',
                        dx: 5,

                        sort: { y: 'x', reverse: true }
                    }
                    )),
                PlotGridX(),
            )

            const plot = Plot.plot(obj);

            plot.appendChild(createRectLegend(listLegend, { color: budget.selectedColorScheme }));
            plot.addEventListener('dblclick', e => downloadSVG(e.target, `${type.colOrigin}.svg`));
            return plot;
        }


        function roundUp(v, percent = 1) {
            let base = 10;

            while (v >= base) {
                base = base * 10;
            }

            base = base / 10;

            const p = Math.floor(v / base);
            return p * base * percent;
        }

        function appendChildPage(e, child) {
            const pages = Array.from(e.querySelectorAll('.page'));
            let lastPage = undefined;

            // find or create lastPage
            if (0 === pages.length) {
                const section = document.createElement('section');
                section.classList.add('page');
                e.appendChild(section);
                lastPage = section;
            } else {
                lastPage = pages.at(-1);
            }

            // lastPage height
            const rect = lastPage.getBoundingClientRect();

            const lastBottom = getHeightChild(lastPage);
            let newHeight = ~~child.getAttribute('height');

            if ('FIGURE' === child.tagName) {
                // figure height is 33
                const h = child.childNodes[1].getAttribute('height');
                newHeight = 33 + parseInt(h);
            }

            // condition may require padding !
            if (rect.height < (lastBottom + newHeight)) {
                const newSection = document.createElement('section');
                newSection.classList.add('page');
                lastPage = newSection;
                e.appendChild(newSection);
            }
            lastPage.appendChild(child);

            updateAllRectLegend();

            // // test blob
            // const blob = createBlob(child);
            // const anchor = document.createElement('a');
            // anchor.href = URL.createObjectURL(blob);
            // anchor.download = 'export.svg';
            // anchor.textContent = 'down';
            // lastPage.appendChild(anchor)
        }

        function downloadSVG(e, filename) {
            const blob = createBlob(e);
            const anchor = document.createElement('a');
            anchor.href = URL.createObjectURL(blob);
            anchor.download = filename;
            anchor.style.display = 'none';
            document.body.appendChild(anchor);
            anchor.click();
            document.body.removeChild(anchor);
        }

        function createBlob(e) {
            const data = new XMLSerializer().serializeToString(e);
            const blob = new Blob([data], { type: "image/svg+xml;charset=utf-8" });

            return blob;
        }

        function getHeightChild(e) {
            let bottom = 0;

            for (const child of e.children) {
                const rect = child.getBoundingClientRect();
                bottom = bottom + rect.height;
            }

            return bottom;
        }
    </script>
</body>

</html>