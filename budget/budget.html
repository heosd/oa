<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <style>
        * {
            box-sizing: border-box;
        }

        @page {
            size: A4;
            marks: crop cross;
        }

        .page {
            width: 210mm;
            height: 297mm;
            margin: 0 auto;
            border: 1px solid black;
            display: block;
            padding: 1.5cm 1.5cm 2cm 1.5cm;
        }

        .color1 {
            color: #DCE2F0;
        }

        .bg1 {
            background-color: #DCE2F0;
        }

        .color2 {
            color: #50586C;
        }

        .bg2 {
            background-color: #50586C;
        }

        .font1-fantasy {
            color: #1E4174;
            font-family: fantasy;
        }

        body {
            font-family: "Open Sans", sans-serif;
            line-height: 1.25;
        }


        table {
            border-collapse: collapse;
        }

        th,
        td {
            border: 1px solid #ccc;
            padding: 8px;
        }

        tr:hover {
            background: #50586C;
            color: #DCE2F0;
        }

        caption {
            text-align: left;
        }
    </style>
</head>

<body>

    <div id="area-test"></div>
    <div id="area-plot-total"></div>
    <div id="area-plot-year"></div>
    <section id="testarea" class="page">
        <div id="sum-date-plot"></div>

        <div id="sum-type-plot"></div>
    </section>

    <!-- Summary -->
    <section class="page">
        <div class="color2">
            <h1>Budget data report</h1>

            <table style="width: 100%; text-align: center;">
                <caption>Data source - <span id="sum-count-datasource"></span> items. first <span
                        id="sum-count-first"></span> items</caption>
                <thead>
                    <tr id="sum-tr-rowcol">
                    </tr>
                </thead>
                <tbody id="sum-area-datasource"></tbody>
            </table>

            <table>
                <caption>Option input</caption>
                <thead>
                    <tr>
                        <th>Attr</th>
                        <th>Value</th>
                        <th>O</th>
                        <th>X</th>
                        <th>Groups (count)</th>
                    </tr>
                </thead>
                <tbody id="sum-area-opt"></tbody>
            </table>
        </div>

    </section>





    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6"></script>

    <script src="../js/Generator.js"></script>
    <script src="../js/DataBudget.js"></script>

    <script>
        setTimeout(async () => {
            const data = await Generator.Generate(300);

            const budget = new DataBudget();
            budget.dataSource = data;
            budget.opt = {
                date: 'date',
                price: 'price',
                count: 'count',
                type: ['name', 'type1', 'type2']
            }

            budget.processClone();
            budget.execDate();
            budget.execPCV();
            budget.execType();
            budget.execYears();

            console.log(budget.opt);
            console.log(budget.cloned);
            console.log(budget.ssDate);
            console.log(budget.ssPCV);
            console.log(budget.ssType);
            console.log(budget.ssYear);

            refreshSummary(budget);
        }, 1);

        function createE(tag, text) {
            const e = document.createElement(tag);
            if (undefined !== typeof text) {
                e.textContent = text;
            }

            return e;
        }

        function getDefaultPlot() {
            const obj = {
                style: { fontSize: 12 },
                marginLeft: 150,
                marginBottom: 45,
                marginTop: 35,
                marginRight: 20,
                x: { grid: true, tickFormat: formatKRW },
                // y: { tickFormat: d => d.toString(), type: 'band' },
                marks: [
                    Plot.frame({ stroke: '#BBB' }),
                    Plot.ruleX([0]),
                ]
            };
            return obj;
        }

        function PlotGridX() {
            return Plot.gridX({ stroke: "white", strokeOpacity: 0.5 });
        }

        function refreshSummary(budget) {
            // -- data source
            document.getElementById('sum-count-datasource').textContent = budget.dataSource.length;

            // cols
            const trHeader = document.getElementById('sum-tr-rowcol');
            const first = budget.dataSource[0];
            const keys = Object.keys(first);
            keys.forEach(k => trHeader.appendChild(createE('th', k)));

            // 5 items or less
            const maxLen = Math.min(5, budget.dataSource.length);
            document.getElementById('sum-count-first').textContent = maxLen;
            const areaDataSource = document.getElementById('sum-area-datasource');
            for (let i = 0; i < maxLen; i++) {
                const item = budget.dataSource[i];
                const tr = document.createElement('tr');
                keys.forEach(k => {
                    const str = item[k].toString();
                    let short = item[k].toString().substring(0, 8);
                    if (8 < str.length) {
                        short = short + '..';
                    }
                    const th = createE('th', short);
                    th.setAttribute('title', str);
                    tr.appendChild(th);
                });
                areaDataSource.appendChild(tr);
            }

            // -- option
            const opt = budget.opt;
            const areaOpt = document.getElementById('sum-area-opt');

            // preprocess
            const dateGroups = budget.ssDate.list.map(d => `${d.y} [${d.count}]`).join(', ');

            const listOptions =
                [
                    ['date', opt.date, budget.ssDate.valid.toString(), budget.ssDate.invalid.toString(), dateGroups],
                    ['price', opt.price, budget.ssPCV.pvalid, budget.ssPCV.pinvalid, budget.ssPCV.prange.join(' ~ ')],
                    ['count', opt.count, budget.ssPCV.cvalid, budget.ssPCV.cinvalid, budget.ssPCV.crange.join(' ~ ')],
                ];

            budget.ssType.forEach(d => {
                const typeGroups = d.list.map(typeItem => `${typeItem.key} [${typeItem.count}]`).join(', ');
                const item = ['type', d.colOrigin, d.valid, d.invalid, typeGroups];
                listOptions.push(item);
            });

            listOptions.forEach(line => {
                const trOpt = document.createElement('tr');
                line.forEach(d => {
                    const td = createE('td', d);
                    trOpt.appendChild(td);
                });
                areaOpt.appendChild(trOpt);
            });

            // max range
            const listMax = [];

            if (budget.optDate) {
                listMax.push(Math.max(...budget.ssDate.list.map(d => d.sum)));
            }

            if (budget.ssType && 0 < budget.ssType.length) {
                budget.ssType.forEach(ss => {
                    listMax.push(Math.max(...ss.list.map(d => d.sum)));
                });
            }

            const max = Math.max(...listMax);
            const range = roundUp(max, 1.3);


            const plotTotal = document.getElementById('area-plot-total');
            // -- Plot date
            if (budget.optDate) {
                const pplot = document.getElementById('sum-date-plot');
                const plot = createDatePlot(budget, range);
                appendChildPage(plotTotal, plot);

                // pplot.appendChild(plot);
            }

            // -- Plot Types
            if (budget.ssType && 0 < budget.ssType.length) {
                const pplot = document.getElementById('sum-type-plot');
                pplot.innerHTML = '';

                budget.ssType.forEach((d, i) => {
                    const plot = createTypePlot(d, d3.schemeAccent[i], range);
                    appendChildPage(plotTotal, plot);
                    // pplot.appendChild(svg);
                });

            } else {
                // no types found
                document.getElementById('sum-types').textContent = '0';
            }

            const svg = createTypePlot2(budget.cloned);
            appendChildPage(plotTotal, svg);

        }

        function refreshLatestYear(budget, range) {
            // console.log(budget, range);
            // const latestYear = parseInt(budget.ssDate.list.at(-1).y);
            // const list = budget.dataCloned.filter(d => d.y === latestYear);
            // console.log(list);
            // console.log(late/stYear);
        }


        function formatKRW(krw) {
            if (0 === krw) {
                return '0';
            }

            const list = [
                [100000000, '억'],
                [10000000, '천만'],
                [1000000, '백만'],
                [100000, '십만'],
                [10000, '만'],
                [1000, '천'],
            ];

            const unit = list.find(d => d[0] <= krw ? true : false);
            const v = krw / unit[0];
            return v + unit[1];
        }

        function createDatePlot(budget, maxRange) {
            const src = budget.ssDate.list;

            // plot
            const obj = getDefaultPlot();
            obj.x = { label: null, grid: true, tickFormat: formatKRW, domain: [0, maxRange] };
            obj.y = { label: 'Year', tickFormat: d => d.toString(), type: 'band' };
            obj.marks.push(
                Plot.barX(src, { x: 'sum', y: 'y', fill: 'steelblue' }),
                Plot.ruleX([0]),
                Plot.text(src, {
                    text: 'sum',
                    x: 'sum',
                    y: 'y',
                    textAnchor: 'start',
                    dx: 5,
                }),
                Plot.text(['Total spent by years'], { frameAnchor: 'top', dy: -20 }),
                PlotGridX(),
            );

            return Plot.plot(obj);
        }

        function createTypePlot(dataSource, fill, maxRange) {
            const src = dataSource;

            // plot
            const obj = getDefaultPlot();
            obj.x = { grid: true, label: null, domain: [0, maxRange], tickFormat: formatKRW };
            obj.y = {
                label: src.colOrigin,
                tickFormat: d => {
                    if (10 <= d.length) {
                        return d.substring(0, 10) + '..';
                    } else {
                        return d;
                    }
                },
            };
            obj.color = {
                scheme: 'RdBu'
            };

            obj.marks.push(
                Plot.barX(src.list, {
                    x: "sum",
                    y: "key",
                    fill: 'd_y',
                    sort: { y: "x", reverse: true }
                }),
                // Plot.barX(src.list, 
                //     Plot.groupY({x: 'count'}, {
                //     y: "key",
                //     fill: 'Response',
                //     sort: { y: "x", reverse: true }
                // })),
                Plot.text(src.list, {
                    text: 'sum',
                    x: 'sum',
                    y: 'key',
                    textAnchor: 'start',
                    dx: 5,
                    fontSize: 12,
                }),
                PlotGridX(),
                Plot.text([`Total spent by ${src.colOrigin}`], { frameAnchor: 'top', dy: -20 }),
            )

            return Plot.plot(obj);
        }

        function createTypePlot2(dataSource, fill, maxRange) {
            const src = dataSource;

            // plot
            const obj = {marks: []};
            obj.color = {
                legend: true,
                scheme: 'Accent'
            };

            obj.marks.push(
                Plot.barX(src, 
                    Plot.groupY({
                        x: 'sum'
                    }, {
                        x: 'v',
                        y: 'type0',
                        fill: 'd_y',
                        tip: true,
                    }
                )),
                Plot.ruleX([0])
            )

            return Plot.plot(obj);
        }

        function createPlottest(src, opt) {
            const data = src;

            const obj = {
                marginLeft: 60,
                color: { legend: true },
                x: {
                    grid: true,
                    label: 'Value',
                    tickFormat: formatKRW,
                },
                y: { label: null },
                marks: [
                    Plot.rectY(data, {
                        x: 'x',
                        y: 'y',
                        stroke: 'y',
                        strokeWidth: 3,
                        sort: 'x',
                    }),
                    // dot at end
                    Plot.dot(data, {
                        x: 'x',
                        y: 'y',
                        fill: 'y',
                        r: 3
                    }),
                    Plot.text(data, {
                        x: 'x',
                        y: 'y',
                        textAnchor: 'start',
                        dx: 5,
                        text: 'x',
                    }),
                    Plot.ruleX([0]),
                ]
            };

            // options
            if (0 < opt.maxRange) {
                obj.x.domain = [0, opt.maxRange];
            }

            if (opt.title) {
                const text = Plot.text([opt.title], { fontSize: 20, frameAnchor: 'top', dy: -20 });
                obj.marks.push(text);
            }

            return obj;
        }

        function createPlotY(src, opt) {
            const data = src;

            const yi = data.map(d => d.y);
            const sy = d3.scaleOrdinal(data.map(d => d.y), Array.from(Array(data.length - 1).keys()));
            const syinvert = d3.scaleOrdinal(sy.range(), sy.domain());

            const obj = {
                marginLeft: 60,
                color: { legend: true },
                x: {
                    grid: true,
                    label: 'Value',
                    tickFormat: formatKRW,
                },
                y: { label: null, tickFormat: d => syinvert(d), ticks: sy.range() },
                marks: [
                    Plot.ruleY(data, {
                        x: 'x',
                        y: d => sy(d.y),
                        stroke: 'y',
                        strokeWidth: 3,
                    }),
                    // dot at end
                    // Plot.dot(data, {
                    //     x: 'x',
                    //     y: 'y',
                    //     fill: 'y',
                    //     r: 3
                    // }),
                    // Plot.text(data, {
                    //     x: 'x',
                    //     y: 'y',
                    //     textAnchor: 'start',
                    //     dx: 5,
                    //     text: 'x',
                    // }),
                    Plot.ruleX([0]),
                ]
            };

            // options
            if (0 < opt.maxRange) {
                obj.x.domain = [0, opt.maxRange];
            }

            if (opt.title) {
                const text = Plot.text([opt.title], { fontSize: 20, frameAnchor: 'top', dy: -20 });
                obj.marks.push(text);
            }

            return obj;

        }


        function rollupxy(src, g) {
            const typeV = typeof v;
            const typeG = typeof g;
            const rr = d3.rollups(src,
                (list) => d3.sum(list, d => d.v)
                , (d) => {
                    if ('string' === typeG) {
                        return d[g];
                    } else if ('function' === typeG) {
                        return g(d);
                    }
                });

            const xy = rr.map(d => { return { x: d[1], y: d[0] } });
            return xy;
        }

        function roundUp(v, percent = 1) {
            let base = 10;

            while (v >= base) {
                base = base * 10;
            }

            base = base / 10;

            const p = Math.floor(v / base);
            return p * base * percent;
        }

        function appendChildPage(e, child) {
            const pages = Array.from(e.querySelectorAll('.page'));
            let lastPage = undefined;

            // find or create lastPage
            if (0 === pages.length) {
                const section = document.createElement('section');
                section.classList.add('page');
                e.appendChild(section);
                lastPage = section;
            } else {
                lastPage = pages.at(-1);
            }

            // lastPage height
            const rect = lastPage.getBoundingClientRect();

            const lastBottom = getHeightChild(lastPage);
            const newHeight = ~~child.getAttribute('height');
            // condition may require padding !
            if (rect.height < (lastBottom + newHeight)) {
                const newSection = document.createElement('section');
                newSection.classList.add('page');
                newSection.appendChild(child);
                e.appendChild(newSection);
            } else {
                lastPage.appendChild(child);
            }
        }

        function getHeightChild(e) {
            let bottom = 0;

            for (const child of e.children) {
                const rect = child.getBoundingClientRect();
                bottom = bottom + rect.height;
            }

            return bottom;
        }
    </script>
</body>

</html>